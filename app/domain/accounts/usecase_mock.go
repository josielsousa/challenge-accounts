// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package accounts

import (
	"context"
	"sync"
)

// Ensure, that UsecaseMock does implement Usecase.
// If this is not the case, regenerate this file with moq.
var _ Usecase = &UsecaseMock{}

// UsecaseMock is a mock implementation of Usecase.
//
//	func TestSomethingThatUsesUsecase(t *testing.T) {
//
//		// make and configure a mocked Usecase
//		mockedUsecase := &UsecaseMock{
//			CreateFunc: func(ctx context.Context, acc AccountInput) error {
//				panic("mock out the Create method")
//			},
//			GetAccountBalanceFunc: func(ctx context.Context, accountID string) (int, error) {
//				panic("mock out the GetAccountBalance method")
//			},
//			GetAllAccountsFunc: func(ctx context.Context) ([]AccountOutput, error) {
//				panic("mock out the GetAllAccounts method")
//			},
//		}
//
//		// use mockedUsecase in code that requires Usecase
//		// and then make assertions.
//
//	}
type UsecaseMock struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, acc AccountInput) error

	// GetAccountBalanceFunc mocks the GetAccountBalance method.
	GetAccountBalanceFunc func(ctx context.Context, accountID string) (int, error)

	// GetAllAccountsFunc mocks the GetAllAccounts method.
	GetAllAccountsFunc func(ctx context.Context) ([]AccountOutput, error)

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Acc is the acc argument value.
			Acc AccountInput
		}
		// GetAccountBalance holds details about calls to the GetAccountBalance method.
		GetAccountBalance []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AccountID is the accountID argument value.
			AccountID string
		}
		// GetAllAccounts holds details about calls to the GetAllAccounts method.
		GetAllAccounts []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockCreate            sync.RWMutex
	lockGetAccountBalance sync.RWMutex
	lockGetAllAccounts    sync.RWMutex
}

// Create calls CreateFunc.
func (mock *UsecaseMock) Create(ctx context.Context, acc AccountInput) error {
	if mock.CreateFunc == nil {
		panic("UsecaseMock.CreateFunc: method is nil but Usecase.Create was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Acc AccountInput
	}{
		Ctx: ctx,
		Acc: acc,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, acc)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedUsecase.CreateCalls())
func (mock *UsecaseMock) CreateCalls() []struct {
	Ctx context.Context
	Acc AccountInput
} {
	var calls []struct {
		Ctx context.Context
		Acc AccountInput
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// GetAccountBalance calls GetAccountBalanceFunc.
func (mock *UsecaseMock) GetAccountBalance(ctx context.Context, accountID string) (int, error) {
	if mock.GetAccountBalanceFunc == nil {
		panic("UsecaseMock.GetAccountBalanceFunc: method is nil but Usecase.GetAccountBalance was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		AccountID string
	}{
		Ctx:       ctx,
		AccountID: accountID,
	}
	mock.lockGetAccountBalance.Lock()
	mock.calls.GetAccountBalance = append(mock.calls.GetAccountBalance, callInfo)
	mock.lockGetAccountBalance.Unlock()
	return mock.GetAccountBalanceFunc(ctx, accountID)
}

// GetAccountBalanceCalls gets all the calls that were made to GetAccountBalance.
// Check the length with:
//
//	len(mockedUsecase.GetAccountBalanceCalls())
func (mock *UsecaseMock) GetAccountBalanceCalls() []struct {
	Ctx       context.Context
	AccountID string
} {
	var calls []struct {
		Ctx       context.Context
		AccountID string
	}
	mock.lockGetAccountBalance.RLock()
	calls = mock.calls.GetAccountBalance
	mock.lockGetAccountBalance.RUnlock()
	return calls
}

// GetAllAccounts calls GetAllAccountsFunc.
func (mock *UsecaseMock) GetAllAccounts(ctx context.Context) ([]AccountOutput, error) {
	if mock.GetAllAccountsFunc == nil {
		panic("UsecaseMock.GetAllAccountsFunc: method is nil but Usecase.GetAllAccounts was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAllAccounts.Lock()
	mock.calls.GetAllAccounts = append(mock.calls.GetAllAccounts, callInfo)
	mock.lockGetAllAccounts.Unlock()
	return mock.GetAllAccountsFunc(ctx)
}

// GetAllAccountsCalls gets all the calls that were made to GetAllAccounts.
// Check the length with:
//
//	len(mockedUsecase.GetAllAccountsCalls())
func (mock *UsecaseMock) GetAllAccountsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetAllAccounts.RLock()
	calls = mock.calls.GetAllAccounts
	mock.lockGetAllAccounts.RUnlock()
	return calls
}
