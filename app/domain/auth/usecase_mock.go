// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package auth

import (
	"context"
	"github.com/josielsousa/challenge-accounts/app/domain/entities"
	"github.com/josielsousa/challenge-accounts/types"
	"sync"
)

// Ensure, that SignerMock does implement Signer.
// If this is not the case, regenerate this file with moq.
var _ Signer = &SignerMock{}

// SignerMock is a mock implementation of Signer.
//
//	func TestSomethingThatUsesSigner(t *testing.T) {
//
//		// make and configure a mocked Signer
//		mockedSigner := &SignerMock{
//			SignTokenFunc: func(id string, username string) (types.Auth, error) {
//				panic("mock out the SignToken method")
//			},
//		}
//
//		// use mockedSigner in code that requires Signer
//		// and then make assertions.
//
//	}
type SignerMock struct {
	// SignTokenFunc mocks the SignToken method.
	SignTokenFunc func(id string, username string) (types.Auth, error)

	// calls tracks calls to the methods.
	calls struct {
		// SignToken holds details about calls to the SignToken method.
		SignToken []struct {
			// ID is the id argument value.
			ID string
			// Username is the username argument value.
			Username string
		}
	}
	lockSignToken sync.RWMutex
}

// SignToken calls SignTokenFunc.
func (mock *SignerMock) SignToken(id string, username string) (types.Auth, error) {
	if mock.SignTokenFunc == nil {
		panic("SignerMock.SignTokenFunc: method is nil but Signer.SignToken was just called")
	}
	callInfo := struct {
		ID       string
		Username string
	}{
		ID:       id,
		Username: username,
	}
	mock.lockSignToken.Lock()
	mock.calls.SignToken = append(mock.calls.SignToken, callInfo)
	mock.lockSignToken.Unlock()
	return mock.SignTokenFunc(id, username)
}

// SignTokenCalls gets all the calls that were made to SignToken.
// Check the length with:
//
//	len(mockedSigner.SignTokenCalls())
func (mock *SignerMock) SignTokenCalls() []struct {
	ID       string
	Username string
} {
	var calls []struct {
		ID       string
		Username string
	}
	mock.lockSignToken.RLock()
	calls = mock.calls.SignToken
	mock.lockSignToken.RUnlock()
	return calls
}

// Ensure, that HasherMock does implement Hasher.
// If this is not the case, regenerate this file with moq.
var _ Hasher = &HasherMock{}

// HasherMock is a mock implementation of Hasher.
//
//	func TestSomethingThatUsesHasher(t *testing.T) {
//
//		// make and configure a mocked Hasher
//		mockedHasher := &HasherMock{
//			VerifySecretFunc: func(hashedSecret string, secret string) error {
//				panic("mock out the VerifySecret method")
//			},
//		}
//
//		// use mockedHasher in code that requires Hasher
//		// and then make assertions.
//
//	}
type HasherMock struct {
	// VerifySecretFunc mocks the VerifySecret method.
	VerifySecretFunc func(hashedSecret string, secret string) error

	// calls tracks calls to the methods.
	calls struct {
		// VerifySecret holds details about calls to the VerifySecret method.
		VerifySecret []struct {
			// HashedSecret is the hashedSecret argument value.
			HashedSecret string
			// Secret is the secret argument value.
			Secret string
		}
	}
	lockVerifySecret sync.RWMutex
}

// VerifySecret calls VerifySecretFunc.
func (mock *HasherMock) VerifySecret(hashedSecret string, secret string) error {
	if mock.VerifySecretFunc == nil {
		panic("HasherMock.VerifySecretFunc: method is nil but Hasher.VerifySecret was just called")
	}
	callInfo := struct {
		HashedSecret string
		Secret       string
	}{
		HashedSecret: hashedSecret,
		Secret:       secret,
	}
	mock.lockVerifySecret.Lock()
	mock.calls.VerifySecret = append(mock.calls.VerifySecret, callInfo)
	mock.lockVerifySecret.Unlock()
	return mock.VerifySecretFunc(hashedSecret, secret)
}

// VerifySecretCalls gets all the calls that were made to VerifySecret.
// Check the length with:
//
//	len(mockedHasher.VerifySecretCalls())
func (mock *HasherMock) VerifySecretCalls() []struct {
	HashedSecret string
	Secret       string
} {
	var calls []struct {
		HashedSecret string
		Secret       string
	}
	mock.lockVerifySecret.RLock()
	calls = mock.calls.VerifySecret
	mock.lockVerifySecret.RUnlock()
	return calls
}

// Ensure, that RepositoryMock does implement Repository.
// If this is not the case, regenerate this file with moq.
var _ Repository = &RepositoryMock{}

// RepositoryMock is a mock implementation of Repository.
//
//	func TestSomethingThatUsesRepository(t *testing.T) {
//
//		// make and configure a mocked Repository
//		mockedRepository := &RepositoryMock{
//			GetByCPFFunc: func(ctx context.Context, cpf string) (entities.Account, error) {
//				panic("mock out the GetByCPF method")
//			},
//		}
//
//		// use mockedRepository in code that requires Repository
//		// and then make assertions.
//
//	}
type RepositoryMock struct {
	// GetByCPFFunc mocks the GetByCPF method.
	GetByCPFFunc func(ctx context.Context, cpf string) (entities.Account, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetByCPF holds details about calls to the GetByCPF method.
		GetByCPF []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Cpf is the cpf argument value.
			Cpf string
		}
	}
	lockGetByCPF sync.RWMutex
}

// GetByCPF calls GetByCPFFunc.
func (mock *RepositoryMock) GetByCPF(ctx context.Context, cpf string) (entities.Account, error) {
	if mock.GetByCPFFunc == nil {
		panic("RepositoryMock.GetByCPFFunc: method is nil but Repository.GetByCPF was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Cpf string
	}{
		Ctx: ctx,
		Cpf: cpf,
	}
	mock.lockGetByCPF.Lock()
	mock.calls.GetByCPF = append(mock.calls.GetByCPF, callInfo)
	mock.lockGetByCPF.Unlock()
	return mock.GetByCPFFunc(ctx, cpf)
}

// GetByCPFCalls gets all the calls that were made to GetByCPF.
// Check the length with:
//
//	len(mockedRepository.GetByCPFCalls())
func (mock *RepositoryMock) GetByCPFCalls() []struct {
	Ctx context.Context
	Cpf string
} {
	var calls []struct {
		Ctx context.Context
		Cpf string
	}
	mock.lockGetByCPF.RLock()
	calls = mock.calls.GetByCPF
	mock.lockGetByCPF.RUnlock()
	return calls
}
